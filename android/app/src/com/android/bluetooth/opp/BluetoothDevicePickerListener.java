/*
 * Copyright (c) 2008-2009, Motorola, Inc.
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * - Neither the name of the Motorola, Inc. nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

package com.android.bluetooth.opp;

import com.android.bluetooth.opp.BluetoothDevicePickerManager.ExtendedBluetoothState;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothError;
import android.bluetooth.BluetoothIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Handler;
import android.util.Log;

import android.app.NotificationManager;

/**
 * BluetoothEventRedirector receives broadcasts and callbacks from the Bluetooth
 * API and dispatches the event on the UI thread to the right class in the
 * Settings.
 */
public class BluetoothDevicePickerListener {
    public static final int NOTIFICATION_ID = android.R.drawable.stat_sys_data_bluetooth;

    private static final String TAG = "BluetoothDevicePickerListener";

    private static final boolean V = BluetoothDevicePickerManager.V;

    private BluetoothDevicePickerManager mManager;

    private Handler mUiHandler = new Handler();

    private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (V) {
                Log.v(TAG, "Received " + intent.getAction());
            }

            String action = intent.getAction();
            BluetoothDevice remoteDevice = intent.getParcelableExtra(BluetoothIntent.DEVICE);

            if (action.equals(BluetoothIntent.BLUETOOTH_STATE_CHANGED_ACTION)) {
                int state = intent.getIntExtra(BluetoothIntent.BLUETOOTH_STATE,
                        BluetoothError.ERROR);
                if (state == BluetoothAdapter.BLUETOOTH_STATE_ON) {
                    mManager.setBluetoothStateInt(ExtendedBluetoothState.ENABLED);
                } else if (state == BluetoothAdapter.BLUETOOTH_STATE_OFF) {
                    mManager.setBluetoothStateInt(ExtendedBluetoothState.DISABLED);
                }
            } else if (action.equals(BluetoothIntent.DISCOVERY_STARTED_ACTION)) {
                mManager.onScanningStateChanged(true);
            } else if (action.equals(BluetoothIntent.DISCOVERY_COMPLETED_ACTION)) {
                mManager.onScanningStateChanged(false);

            } else if (action.equals(BluetoothIntent.PAIRING_REQUEST_ACTION)) {
                Intent pinIntent = new Intent();
                pinIntent.setClass(context, BluetoothPinDialog.class);
                pinIntent.putExtra(BluetoothIntent.DEVICE, remoteDevice);
                pinIntent.setAction(BluetoothIntent.PAIRING_REQUEST_ACTION);
                pinIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                // if this activity is in the foreground, open the pin dialog,
                // else ignore
                if (mManager.getForegroundActivity() != null) {
                    context.startActivity(pinIntent);
                }

                /* clear the notification generated by Bluetooth Settings */
                NotificationManager manager = (NotificationManager)context
                        .getSystemService(Context.NOTIFICATION_SERVICE);
                manager.cancel(NOTIFICATION_ID);
                Log.v(TAG, "###after cancel");

            } else if (action.equals(BluetoothIntent.REMOTE_DEVICE_FOUND_ACTION)) {
                short rssi = intent.getShortExtra(BluetoothIntent.RSSI, Short.MIN_VALUE);
                Log.v(TAG, "onReceive: REMOTE_DEVICE_FOUND_ACTION");
                mManager.getLocalDeviceManager().onDeviceAppeared(remoteDevice, rssi);
            } else if (action.equals(BluetoothIntent.REMOTE_DEVICE_DISAPPEARED_ACTION)) {
                mManager.getLocalDeviceManager().onDeviceDisappeared(remoteDevice);
            } else if (action.equals(BluetoothIntent.REMOTE_NAME_UPDATED_ACTION)) {
                mManager.getLocalDeviceManager().onDeviceNameUpdated(remoteDevice);
            } else if (action.equals(BluetoothIntent.BOND_STATE_CHANGED_ACTION)) {
                Log.v(TAG, "onReceive: BOND_STATE_CHANGED_ACTION");
                int bondResult = intent.getIntExtra(BluetoothIntent.BOND_STATE, 99);
                if (bondResult == BluetoothDevice.BOND_BONDED) {
                    Log.v(TAG, "onReceive: BOND_STATE_CHANGED_ACTION, BONDED");
                    mManager.getLocalDeviceManager().onBondingStateChanged(remoteDevice, true);
                } else if (bondResult == BluetoothDevice.BOND_NOT_BONDED) {
                    Log.v(TAG, "onReceive: BOND_STATE_CHANGED_ACTION, NOT_BONDED");
                    mManager.getLocalDeviceManager().onBondingStateChanged(remoteDevice, false);
                }
            }
        }
    };

    public BluetoothDevicePickerListener(
            BluetoothDevicePickerManager localBluetoothDevicePickerManager) {
        mManager = localBluetoothDevicePickerManager;
    }

    public void start() {
        IntentFilter filter = new IntentFilter();
        Log.v(TAG, "start");

        // Bluetooth on/off broadcasts
        filter.addAction(BluetoothIntent.BLUETOOTH_STATE_CHANGED_ACTION);

        // Discovery broadcasts
        filter.addAction(BluetoothIntent.DISCOVERY_STARTED_ACTION);
        filter.addAction(BluetoothIntent.DISCOVERY_COMPLETED_ACTION);
        filter.addAction(BluetoothIntent.REMOTE_DEVICE_DISAPPEARED_ACTION);
        filter.addAction(BluetoothIntent.REMOTE_DEVICE_FOUND_ACTION);
        filter.addAction(BluetoothIntent.REMOTE_NAME_UPDATED_ACTION);

        // Pairing broadcasts
        filter.addAction(BluetoothIntent.BOND_STATE_CHANGED_ACTION);

        // Pin request
        filter.addAction(BluetoothIntent.PAIRING_REQUEST_ACTION);
        filter.addAction(BluetoothIntent.PAIRING_CANCEL_ACTION);

        mManager.getContext().registerReceiver(mBroadcastReceiver, filter);
    }

    public void stop() {
        mManager.getContext().unregisterReceiver(mBroadcastReceiver);
    }

}
